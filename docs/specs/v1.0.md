# MIND Language Specification v1.0 (Working Draft)

> Status: Draft; evolves via RFCs in `docs/rfcs/`.

## 1. Lexical Grammar

### Phase 1 subset
- Ident: `[a-zA-Z_][a-zA-Z0-9_]*`
- Int: `[0-9]+`
## 2. Types (Tensor[T, Shape], device placement, effects)
### Phase 3A subset
- `ValueType`: `Scalar(i32)` and `Tensor(TensorType)` (tensor placeholder for future phases).
- Literals: `Int` → `Scalar(i32)`.
- Identifiers: resolved from the type environment.
- Binary `+`, `-`, `*`, `/`: require both operands `Scalar(i32)`; result `Scalar(i32)`.
## 3. Expressions and Statements

### Phase 1 subset
- `Node::Lit(Ident|Int)`, `Module { items: Vec<Node> }`

### Phase 2 subset (prototype)
- Literals: `Int`, `Ident`
- Binary ops: `+`, `-`, `*`, `/` with precedence `*` & `/` over `+` & `-`, all left-associative
- Parentheses override precedence

## 3.1 Statements (Phase subset)
- `let <ident> = <expr>`
- `<ident> = <expr>`
- Semicolons/newlines as separators.
- Result value = value of the last statement/expression.

## 3.2 Constant Folding (Phase subset)
- Bottom-up on integer `+ - * /` (skip `÷0`).
## 4. Autodiff Primitives (grad, vjp, jvp)
## 5. Module System and Stdlib Surface
## 6. IR Mapping to MLIR
## 7. Safety, Errors, Diagnostics

### Phase subset (Diagnostics)
- Errors report 1-based line/col and a single-line caret highlight.
- Multi-line spans degrade to single-line best-effort (to be improved later).

## 7.1 REPL (Phase subset)
- Stateful environment: variables persist across inputs.
- Input is parsed as a mini-module (statements separated by `;` or newline).
- Result = last statement/expression value.

## 2.1 Shape Inference (Phase 1)
Left-biased unification:
- Known==Known → Known
- Known↔Sym → Known
- Sym↔Sym → left symbol
- Rank mismatch → missing dims become `UNK` (left-biased)

## 5.1 Stdlib (Phase 1)
`Tensor<T>` placeholder with `zeros/ones/reshape/shape/sum/mean` (no storage).

## 4. Typing (Phase 3A subset)
- `ValueType`: `Scalar(i32)` and `Tensor(TensorType)` (tensor reserved for later).
- Literals: `Int` → `Scalar(i32)`.
- Identifiers: resolved from type environment.
- Binary ops `+ - * /`: both operands must be `Scalar(i32)` → result `Scalar(i32)`.

## 4.2 Type annotations (Phase 3B)
- `let name: i32 = expr`
- `let name: Tensor[dtype,(dims...)] = expr` where `dims` are ints or symbols.
- Annotation seeds the type environment and is validated against the inferred type of `expr`.
- For now, expressions type-check only as scalar arithmetic; tensor annotations are enforced but tensor arithmetic is not yet implemented.

## 4.3 Tensor binary ops & broadcasting (Phase 3C)
- Dtype: `Tensor[f32, S] ⊕ Tensor[f32, T]` → `Tensor[f32, broadcast(S,T))`.
- Scalar promotion: `Scalar(i32) ⊕ Tensor[f32,S]` → `Tensor[f32,S]` (type-level promotion).
- Broadcasting: right-aligned; dim matches if equal, or one is `1`. Symbols must match exactly, or match with `1`.
- On mismatch (dtype or shape), emit type error.
