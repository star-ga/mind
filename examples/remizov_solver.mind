// Copyright 2025-2026 STARGA Inc.
// Licensed under the Apache License, Version 2.0
//
// Remizov ODE Solver — Translation-Based (Theorem 6)
// First universal formula for 2nd-order linear ODEs with variable coefficients
//
// Solves: a(x)f''(x) + b(x)f'(x) + (c(x) - lambda)f(x) = -g(x)
//
// Based on: Remizov, I.D. (2025). "Chernoff approximations as a method for
// finding the resolvent of a linear operator and solving a linear ODE with
// variable coefficients." arXiv:2301.06765v4.
//
// The shift operator S(t) from Theorem 6:
//   S(t)f(x) = (1/4) f(x + 2*sqrt(a(x)*t))
//            + (1/4) f(x - 2*sqrt(a(x)*t))
//            + (1/2) f(x + 2*b(x)*t)
//            + t*c(x)*f(x)
//
// Solution via Chernoff product formula + Laplace transform:
//   f(x) = integral_0^inf e^{-lambda*t} lim_{n->inf} (S(t/n))^n g(x) dt
//
// Error bound: O(1 / (n_iter * (lambda - ||c||)^3))

import std.math;
import std.tensor;

// ============================================================================
// Utility: Evenly spaced grid
// ============================================================================

fn linspace(start: f64, end: f64, n: i32) -> tensor<f64[N]> {
    let step = (end - start) / (n - 1) as f64;
    let grid: tensor<f64[N]> = tensor.zeros[f64, (n,)];
    for i in 0..n {
        grid[i] = start + (i as f64) * step;
    }
    return grid;
}

// ============================================================================
// Utility: Piecewise linear interpolation
// ============================================================================

// Given sorted grid x_grid with values y_grid, evaluate at arbitrary x_query.
// Clamps to boundary values outside the grid domain.
fn interp_linear(x_grid: tensor<f64[N]>, y_grid: tensor<f64[N]>,
                 n: i32, x_query: f64) -> f64 {
    let x_min = x_grid[0];
    let x_max = x_grid[n - 1];

    // Clamp to domain boundaries
    if x_query <= x_min { return y_grid[0]; }
    if x_query >= x_max { return y_grid[n - 1]; }

    // Find interval: x_grid[idx] <= x_query < x_grid[idx+1]
    let step = (x_max - x_min) / (n - 1) as f64;
    let idx_f = (x_query - x_min) / step;
    let idx = idx_f as i32;

    // Guard against floating-point edge case at right boundary
    if idx >= n - 1 { return y_grid[n - 1]; }

    // Linear interpolation within the interval
    let t = idx_f - (idx as f64);
    return y_grid[idx] * (1.0 - t) + y_grid[idx + 1] * t;
}

// ============================================================================
// Gauss-Laguerre Quadrature (32-point)
// ============================================================================
// Nodes and weights for: integral_0^inf e^{-s} f(s) ds ≈ sum_k w_k f(s_k)
//
// To compute integral_0^inf e^{-lambda*t} F(t) dt:
//   Substitute s = lambda*t, so dt = ds/lambda
//   = (1/lambda) integral_0^inf e^{-s} F(s/lambda) ds
//   ≈ (1/lambda) sum_k w_k F(s_k / lambda)

fn gauss_laguerre_nodes_32() -> (tensor<f64[32]>, tensor<f64[32]>) {
    // 32-point Gauss-Laguerre nodes (zeros of L_32(x))
    let nodes: tensor<f64[32]> = [
        0.04448936583326,  0.23452610951961,  0.57688462930188,  1.07244875381782,
        1.72240877231768,  2.52833670642579,  3.49221338556548,  4.61645676974976,
        5.90395850417424,  7.35812673318624,  8.98294092421260, 10.78301863254472,
        12.76369798288079, 14.93113975552256, 17.29245433671532, 19.85586237537753,
        22.63089578245498, 25.62863602245921, 28.86210181632637, 32.34662915396487,
        36.10003201710083, 40.14539087991025, 44.51084695665178, 49.23221903498770,
        54.35529462706445, 59.94214052456898, 66.07764919526498, 72.88080035974944,
        80.52493710494128, 89.30314212536448, 99.88923568498693, 113.69397484942860
    ];

    // Corresponding weights
    let weights: tensor<f64[32]> = [
        0.11405028393994,  0.26114369910692,  0.39491839613498,  0.50633297605388,
        0.58656244033913,  0.62862456092304,  0.62853611776418,  0.58558127293698,
        0.50271293293702,  0.38668846695345,  0.25755230604698,  0.14484433894272,
        0.06728870721018,  0.02503059878258,  0.00726628914072,  0.00160068088993,
        0.00025655993407,  0.00002869561568,  0.00000210889288,  0.00000009506372,
        0.00000000244637,  0.00000000003202,  0.00000000000019,  0.00000000000000,
        0.00000000000000,  0.00000000000000,  0.00000000000000,  0.00000000000000,
        0.00000000000000,  0.00000000000000,  0.00000000000000,  0.00000000000000
    ];

    return (nodes, weights);
}

// ============================================================================
// The Shift Operator S(t) — Theorem 6
// ============================================================================
//
// S(t)f(x) = (1/4) f(x + 2*sqrt(a(x)*t))
//          + (1/4) f(x - 2*sqrt(a(x)*t))
//          + (1/2) f(x + 2*b(x)*t)
//          + t * c(x) * f(x)
//
// Applied to a grid-discretized function h[i] at each grid point x[i].
// Non-grid-point evaluations use linear interpolation.

fn apply_shift_operator(
    x_grid: tensor<f64[N]>,
    h: tensor<f64[N]>,
    n_grid: i32,
    a_vals: tensor<f64[N]>,     // a(x_i) precomputed on grid
    b_vals: tensor<f64[N]>,     // b(x_i) precomputed on grid
    c_vals: tensor<f64[N]>,     // c(x_i) precomputed on grid
    dt: f64                      // time step t/n
) -> tensor<f64[N]> {
    let h_new: tensor<f64[N]> = tensor.zeros[f64, (n_grid,)];

    for i in 0..n_grid {
        let xi = x_grid[i];
        let ai = a_vals[i];
        let bi = b_vals[i];
        let ci = c_vals[i];

        // Compute shifted evaluation points
        let shift_diffusion = 2.0 * sqrt(ai * dt);
        let shift_drift = 2.0 * bi * dt;

        // Evaluate h at shifted points via interpolation
        let h_plus  = interp_linear(x_grid, h, n_grid, xi + shift_diffusion);
        let h_minus = interp_linear(x_grid, h, n_grid, xi - shift_diffusion);
        let h_drift = interp_linear(x_grid, h, n_grid, xi + shift_drift);
        let h_local = h[i];

        // Theorem 6 shift operator
        h_new[i] = 0.25 * h_plus + 0.25 * h_minus + 0.5 * h_drift + dt * ci * h_local;
    }

    return h_new;
}

// ============================================================================
// Core Solver: Remizov Translation-Based (Theorem 6)
// ============================================================================
//
// Algorithm:
//   1. Set up spatial grid x_i = linspace(x_min, x_max, n_grid)
//   2. Precompute a(x_i), b(x_i), c(x_i), g(x_i)
//   3. For each Gauss-Laguerre node s_k with weight w_k:
//      a. Set t_k = s_k / lambda
//      b. Set dt = t_k / n_iter
//      c. Initialize h = g (the right-hand side)
//      d. Apply S(dt) to h, n_iter times: h <- S(dt) h
//      e. Accumulate: f += (w_k / lambda) * h
//   4. Return f on the grid

fn remizov_solve(
    a: fn(f64) -> f64,
    b: fn(f64) -> f64,
    c: fn(f64) -> f64,
    g: fn(f64) -> f64,
    lambda: f64,
    x_min: f64,
    x_max: f64,
    n_grid: i32,
    n_iter: i32,
    n_quad: i32
) -> (tensor<f64[N]>, tensor<f64[N]>) {
    // Step 1: Spatial grid
    let x_grid = linspace(x_min, x_max, n_grid);

    // Step 2: Precompute coefficient values on grid
    let a_vals: tensor<f64[N]> = tensor.zeros[f64, (n_grid,)];
    let b_vals: tensor<f64[N]> = tensor.zeros[f64, (n_grid,)];
    let c_vals: tensor<f64[N]> = tensor.zeros[f64, (n_grid,)];
    let g_vals: tensor<f64[N]> = tensor.zeros[f64, (n_grid,)];

    for i in 0..n_grid {
        a_vals[i] = a(x_grid[i]);
        b_vals[i] = b(x_grid[i]);
        c_vals[i] = c(x_grid[i]);
        g_vals[i] = g(x_grid[i]);
    }

    // Step 3: Gauss-Laguerre quadrature
    let (nodes, weights) = gauss_laguerre_nodes_32();

    // Accumulator for the Laplace integral
    let f_solution: tensor<f64[N]> = tensor.zeros[f64, (n_grid,)];

    // Use effective number of quadrature nodes (trim near-zero weights)
    let n_eff = if n_quad > 32 { 32 } else { n_quad };

    for k in 0..n_eff {
        let s_k = nodes[k];
        let w_k = weights[k];

        // Skip negligible weights
        if w_k < 1e-15 { continue; }

        // Map Gauss-Laguerre node to Laplace variable: t_k = s_k / lambda
        let t_k = s_k / lambda;
        let dt = t_k / (n_iter as f64);

        // Initialize h with right-hand side g
        let h = g_vals;

        // Apply shift operator n_iter times: h <- S(dt)^n_iter g
        for iter in 0..n_iter {
            h = apply_shift_operator(x_grid, h, n_grid, a_vals, b_vals, c_vals, dt);
        }

        // Accumulate weighted contribution: (w_k / lambda) * (S(t_k/n)^n g)(x)
        for i in 0..n_grid {
            f_solution[i] = f_solution[i] + (w_k / lambda) * h[i];
        }
    }

    return (x_grid, f_solution);
}

// ============================================================================
// Richardson Extrapolation (O(1/n) -> O(1/n^2) acceleration)
// ============================================================================
//
// Since the Chernoff error has the form: f_n = f_* + C/n + O(1/n^2)
// Richardson extrapolation gives: f_R = 2*f_{2n} - f_n = f_* + O(1/n^2)
//
// This boosts convergence from first-order to second-order for free:
//   n=32 with Richardson ≈ n=1000 without it.

fn remizov_solve_richardson(
    a: fn(f64) -> f64,
    b: fn(f64) -> f64,
    c: fn(f64) -> f64,
    g: fn(f64) -> f64,
    lambda: f64,
    x_min: f64,
    x_max: f64,
    n_grid: i32,
    n_iter: i32,
    n_quad: i32
) -> (tensor<f64[N]>, tensor<f64[N]>) {
    // Solve with n_iter and 2*n_iter, then extrapolate
    let (x, f_n) = remizov_solve(a, b, c, g, lambda, x_min, x_max,
                                  n_grid, n_iter, n_quad);
    let (_, f_2n) = remizov_solve(a, b, c, g, lambda, x_min, x_max,
                                   n_grid, n_iter * 2, n_quad);

    // Richardson: f_R = 2*f_{2n} - f_n eliminates the O(1/n) term
    let f_richardson: tensor<f64[N]> = tensor.zeros[f64, (n_grid,)];
    for i in 0..n_grid {
        f_richardson[i] = 2.0 * f_2n[i] - f_n[i];
    }

    return (x, f_richardson);
}

// ============================================================================
// Example: Constant-Coefficient ODE
// ============================================================================
//
// Solve: f''(x) - lambda*f(x) = -g(x)
// With a(x) = 1, b(x) = 0, c(x) = 0
// And g(x) = exp(-x^2) (Gaussian source)
//
// For constant coefficients, the analytical solution is known via Green's
// function: f(x) = (1 / 2*sqrt(lambda)) * integral exp(-sqrt(lambda)|x-y|) g(y) dy

fn coeff_a_const(x: f64) -> f64 { return 1.0; }
fn coeff_b_zero(x: f64) -> f64 { return 0.0; }
fn coeff_c_zero(x: f64) -> f64 { return 0.0; }
fn source_gaussian(x: f64) -> f64 { return exp(-x * x); }

fn example_constant_coefficients() {
    print("=== Constant-Coefficient Example ===");
    print("Solving: f''(x) - 4.0*f(x) = -exp(-x^2)\n");

    let lambda = 4.0;
    let (x, f) = remizov_solve(
        coeff_a_const, coeff_b_zero, coeff_c_zero, source_gaussian,
        lambda, -5.0, 5.0,
        200,     // n_grid: 200 spatial points
        500,     // n_iter: 500 Chernoff iterations -> ~0.2% error
        24       // n_quad: 24 quadrature nodes (sufficient for smooth integrands)
    );

    // Print solution at selected points
    for i in [0, 50, 75, 100, 125, 150, 199] {
        print("f(", x[i], ") = ", f[i]);
    }
}

// ============================================================================
// Example: Variable-Coefficient ODE (Airy-type)
// ============================================================================
//
// Solve: f''(x) + x*f'(x) + (0.5 - lambda)*f(x) = -1.0
// With a(x) = 1, b(x) = x, c(x) = 0.5
//
// This has no elementary closed-form solution, demonstrating the power
// of the Remizov formula for equations that classical methods can't handle.

fn coeff_b_linear(x: f64) -> f64 { return x; }
fn coeff_c_half(x: f64) -> f64 { return 0.5; }
fn source_constant(x: f64) -> f64 { return 1.0; }

fn example_variable_coefficients() {
    print("\n=== Variable-Coefficient Example ===");
    print("Solving: f''(x) + x*f'(x) + (0.5 - lambda)*f(x) = -1.0\n");

    let lambda = 2.0;   // Must be > sup|c(x)| = 0.5
    let (x, f) = remizov_solve(
        coeff_a_const, coeff_b_linear, coeff_c_half, source_constant,
        lambda, -3.0, 3.0,
        200, 500, 24
    );

    for i in [0, 50, 100, 150, 199] {
        print("f(", x[i], ") = ", f[i]);
    }
}

// ============================================================================
// Example: Convergence Rate Verification
// ============================================================================
//
// Verify the O(1/n) convergence rate by solving the same problem
// with increasing n_iter and comparing successive solutions.

fn example_convergence() {
    print("\n=== Convergence Rate Verification ===");
    print("Comparing solutions with n_iter = 50, 100, 200, 500, 1000\n");

    let n_iters = [50, 100, 200, 500, 1000];
    let lambda = 4.0;
    let n_grid = 100;

    // Reference solution with high n_iter
    let (x_ref, f_ref) = remizov_solve(
        coeff_a_const, coeff_b_zero, coeff_c_zero, source_gaussian,
        lambda, -5.0, 5.0, n_grid, 2000, 24
    );

    for n in n_iters {
        let (x, f) = remizov_solve(
            coeff_a_const, coeff_b_zero, coeff_c_zero, source_gaussian,
            lambda, -5.0, 5.0, n_grid, n, 24
        );

        // Compute max absolute error vs reference
        let max_err = 0.0;
        for i in 0..n_grid {
            let err = abs(f[i] - f_ref[i]);
            if err > max_err { max_err = err; }
        }
        print("n_iter =", n, " max_error =", max_err);
    }
    print("Expected: errors should decrease proportionally to 1/n_iter");

    // Richardson extrapolation comparison
    print("\n--- With Richardson Extrapolation ---");
    let (_, f_rich) = remizov_solve_richardson(
        coeff_a_const, coeff_b_zero, coeff_c_zero, source_gaussian,
        lambda, -5.0, 5.0, n_grid, 100, 24
    );
    let rich_err = 0.0;
    for i in 0..n_grid {
        let err = abs(f_rich[i] - f_ref[i]);
        if err > rich_err { rich_err = err; }
    }
    print("Richardson (n=100+200) max_error =", rich_err);
    print("Compare: plain n=1000 should have similar error to Richardson n=100");
}

// ============================================================================
// Main
// ============================================================================

fn main() {
    print("MIND Remizov ODE Solver — Translation-Based (Theorem 6)");
    print("========================================================\n");

    example_constant_coefficients();
    example_variable_coefficients();
    example_convergence();

    print("\nDone.");
}
